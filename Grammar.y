{
module Grammar where
import Tokens
import Trike
}

%name parseTrike
%tokentype { Token }
%error { parseError }

-- working on some of the tokens here, removed some we didnt need and 
-- inserted some that we do.  Some more need added, and need to 
-- clarify a bit with some (4/21)

%token
    var    { TokenSym $$ }
    num    { TokenNum $$ }
    '{'    { TokenLBrace }
    '}'    { TokenRBrace }
    'if'   { TokenIf }
    'else' { TokenElse }
    tt     { TokenTrue}
    ff     { TokenFalse}
    '&&'   { TokenAnd}
    '||'   { TokenOr}
    '!'    {TokenNeg}

-- associativity and precedence directives: higher in the file means lower precedence

%right in
%right 'else'
 

%%

Exp

-- the type for the syntax tree generated by this nonterminal
:: { Expr } 
   
{- ambiguous!

    if true then 3 else 4 + 5

   Could be:

    if true then 3 else (4 + 5)

   or:

    (if true then 3 else 4) + 5

   Above precedence directive makes it be the first parse

-}

-- added in some of the productions like && || !
-- more need added, just not entirely sure how
-- need to make sure they're being implemented right 
--(see trike.hs) (4/21)

-- productions:
: let var '=' Exp in Exp { Let $2 $4 $6 }
| 'if' Exp 'else' Exp { Ite $2 $4 }
| '{' Exp '}'            { $2 }
| Exp '&&' Exp           { And $1 $3 }
| Exp '||' Exp		 { Or $1 $3 }
| '!' Exp		 { Not $2 }
| num                  { Number $1 }
| var                    { Var $1 }
| tt                   { Boolean True }
| ff                   { Boolean False }
{

parseError :: [Token] -> a
parseError tks = error ("Parse error: " ++ show tks)

}
